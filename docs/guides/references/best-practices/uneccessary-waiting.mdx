---
title: Unnecessary Waiting
---

:::danger

&#8239;<Icon name="exclamation-triangle" color="red" /> **Anti-Pattern:**
Waiting for arbitrary time periods using
[`cy.wait(Number)`](/api/commands/wait#Time).

:::

:::tip

&#8239;<Icon name="check-circle" color="green" /> **Best Practice:** Use route
aliases or assertions to guard Cypress from proceeding until an explicit
condition is met.

:::

In Cypress, you almost never need to use `cy.wait()` for an arbitrary amount of
time. If you are finding yourself doing this, there is likely a much simpler
way.

Let's imagine the following examples:

### Unnecessary wait for `cy.request()`

Waiting here is unnecessary since the [`cy.request()`](/api/commands/request)
command will not resolve until it receives a response from your server. Adding
the wait here only adds 5 seconds after the
[`cy.request()`](/api/commands/request) has already resolved.

```javascript
cy.request('http://localhost:8080/db/seed')
cy.wait(5000) // <--- this is unnecessary
```

### Unnecessary wait for `cy.visit()` <E2EOnlyBadge />

Waiting for this is unnecessary because the [cy.visit()](/api/commands/visit)
resolves once the page fires its `load` event. By that time all of your assets
have been loaded including javascript, stylesheets, and html.

```javascript
cy.visit('http://localhost/8080')
cy.wait(5000) // <--- this is unnecessary
```

### Unnecessary wait for `cy.get()`

Waiting for the [`cy.get()`](/api/commands/get) below is unnecessary because
[`cy.get()`](/api/commands/get) automatically retries until the table's `tr` has
a length of 2.

Whenever commands have an assertion they will not resolve until their associated
assertions pass. This enables you to describe the state of your application
without having to worry about when it gets there.

```javascript
cy.intercept('GET', '/users', [{ name: 'Maggy' }, { name: 'Joan' }])
cy.get('#fetch').click()
cy.wait(4000) // <--- this is unnecessary
cy.get('table tr').should('have.length', 2)
```

Alternatively a better solution to this problem is by waiting explicitly for an
aliased route.

```javascript
cy.intercept('GET', '/users', [{ name: 'Maggy' }, { name: 'Joan' }]).as(
  'getUsers'
)
cy.get('[data-testid="fetch-users"]').click()
cy.wait('@getUsers') // <--- wait explicitly for this route to finish
cy.get('table tr').should('have.length', 2)
```